<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Tizen Avengers - WebApi Guidelines</title>
	<link href="css/doctor.css" type="text/css" rel="stylesheet">
	<link href="css/print.css" type="text/css" rel="stylesheet" media="print">
</head>
<body>
<div id="nav">
    <h1 class="visible-print">Tizen Avengers - WebApi Guidelines</h1>
	<div class="separator"></div>
	<a title="Tizen Avengers - WebApi Guidelines" class="brand" href="#" style="background-image:url(images/tizen-logo_32h.png)"></a>
	<div class="separator"></div>
	<ul id="sections"><li class="l2"><a href="#revision-history">Revision History</a></li><li class="l2"><a href="#overview">Overview</a></li><li class="l2"><a href="#guideline">Guideline</a><ul><li class="l3"><a href="#guideline/languages">Languages</a></li><li class="l3"><a href="#guideline/codding-style">Codding style</a></li><li class="l3"><a href="#guideline/api-guide">API guide</a></li><li class="l3"><a href="#guideline/unit-test-criteria">Unit test criteria</a></li><li class="l3"><a href="#guideline/source-code">Source code</a></li><li class="l3"><a href="#guideline/license-and-boilerplate">License and Boilerplate</a></li></ul></li><li class="l2"><a href="#plugin-structure">Plugin Structure</a><ul><li class="l3"><a href="#plugin-structure/conventions">Conventions</a></li><li class="l3"><a href="#plugin-structure/structure">Structure</a></li><li class="l3"><a href="#plugin-structure/spec-file">Spec file</a></li><li class="l3"><a href="#plugin-structure/gyp-file">GYP file</a></li><li class="l3"><a href="#plugin-structure/implementation-files">Implementation files</a></li><li class="l3"><a href="#plugin-structure/plugin-flow">Plugin flow</a></li></ul></li><li class="l2"><a href="#widl">WIDL</a><ul><li class="l3"><a href="#widl/conventions">Conventions</a></li><li class="l3"><a href="#widl/architecture">Architecture</a></li><li class="l3"><a href="#widl/example">Example</a></li></ul></li><li class="l2"><a href="#tools">Tools</a><ul><li class="l3"><a href="#tools/generate-stub-code">Generate stub code</a></li><li class="l3"><a href="#tools/using-multiple-javascript-files">Using multiple JavaScript files</a></li></ul></li><li class="l2"><a href="#implementation-javascript">Implementation - JavaScript</a><ul><li class="l3"><a href="#implementation-javascript/interface-creation">Interface creation</a></li><li class="l3"><a href="#implementation-javascript/creating-manager-entity">Creating Manager entity</a></li><li class="l3"><a href="#implementation-javascript/properties-definition">Properties definition</a></li><li class="l3"><a href="#implementation-javascript/methods-definition">Methods definition</a></li><li class="l3"><a href="#implementation-javascript/exporting-interface">Exporting interface</a></li><li class="l3"><a href="#implementation-javascript/utils">Utils</a></li><li class="l3"><a href="#implementation-javascript/exceptions">Exceptions</a></li><li class="l3"><a href="#implementation-javascript/synchronous-methods">Synchronous methods</a></li><li class="l3"><a href="#implementation-javascript/asynchronous-methods">Asynchronous methods</a></li><li class="l3"><a href="#implementation-javascript/listeners">Listeners</a></li></ul></li><li class="l2"><a href="#implementation-c">Implementation - C++</a><ul><li class="l3"><a href="#implementation-c/lifecycle-and-plugin-state">Lifecycle and plugin state</a></li><li class="l3"><a href="#implementation-c/namespace-and-entry-points">Namespace and entry points</a></li><li class="l3"><a href="#implementation-c/plugin-structure">Plugin structure</a></li><li class="l3"><a href="#implementation-c/asynchronous-calls">Asynchronous calls</a></li><li class="l3"><a href="#implementation-c/listeners">Listeners</a></li><li class="l3"><a href="#implementation-c/logger">Logger</a></li><li class="l3"><a href="#implementation-c/error-handling">Error handling</a></li></ul></li><li class="l2"><a href="#devel-package">Devel package</a><ul><li class="l3"><a href="#devel-package/package-structure">Package structure</a></li><li class="l3"><a href="#devel-package/creating-custom-web-device-plugins-module">Creating custom web device plugins module</a></li></ul></li></ul>
	<div class="separator"></div>
	<div class="extra generated">
		Generated by <a href="https://github.com/DimitarChristoff/doctor" target="_blank" title="generate documentation from markdown">Doctor, MD</a>
	</div>
</div>
<div id="content" class="container">
	<h1 id="tizen-avengers-webapi-guidelines">Tizen Avengers - WebApi Guidelines</h1>
<h2 id="revision-history">Revision History</h2>
<table class="table table-striped">
<thead>
<tr>
<th>Version</th>
<th>Date</th>
<th>Description</th>
<th>Editor</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.1.0</td>
<td>2015-05-15</td>
<td>Initial Draft</td>
<td>Wojciech Kosowicz<br><a href="mailto:w.kosowicz@samsung.com">&#119;&#x2e;&#x6b;&#111;&#115;&#x6f;&#119;&#x69;&#99;&#x7a;&#x40;&#115;&#x61;&#x6d;&#x73;&#x75;&#x6e;&#x67;&#46;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>0.2.0</td>
<td>2015-05-22</td>
<td>Extended version</td>
<td>Pawel Kaczmarek<br><a href="mailto:p.kaczmarek3@samsung.com">&#x70;&#x2e;&#x6b;&#x61;&#99;&#x7a;&#109;&#x61;&#x72;&#101;&#x6b;&#51;&#64;&#115;&#97;&#x6d;&#x73;&#117;&#110;&#x67;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>0.2.1</td>
<td>2015-06-01</td>
<td>Proofreading</td>
<td>Rafal Galka<br><a href="mailto:r.galka@samsung.com">&#114;&#46;&#103;&#x61;&#x6c;&#107;&#97;&#x40;&#115;&#97;&#109;&#x73;&#117;&#x6e;&#103;&#46;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>0.3.0</td>
<td>2015-06-08</td>
<td>Supplemented C++ implementation guide</td>
<td>Rafal Galka<br><a href="mailto:r.galka@samsung.com">&#114;&#46;&#x67;&#97;&#108;&#107;&#x61;&#x40;&#115;&#97;&#109;&#x73;&#x75;&#x6e;&#x67;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>0.4.0</td>
<td>2015-06-16</td>
<td>Guideline</td>
<td>Pawel Kaczmarek<br><a href="mailto:p.kaczmarek3@samsung.com">&#x70;&#x2e;&#x6b;&#x61;&#x63;&#x7a;&#109;&#97;&#114;&#x65;&#x6b;&#x33;&#x40;&#115;&#97;&#109;&#x73;&#x75;&#x6e;&#103;&#46;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>0.5.0</td>
<td>2015-06-18</td>
<td>Devel package</td>
<td>Pawel Kaczmarek<br><a href="mailto:p.kaczmarek3@samsung.com">&#x70;&#x2e;&#x6b;&#97;&#x63;&#x7a;&#x6d;&#x61;&#x72;&#101;&#107;&#51;&#x40;&#x73;&#97;&#109;&#x73;&#x75;&#110;&#103;&#46;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>0.5.1</td>
<td>2015-06-24</td>
<td>Add info about WAPIOven.py</td>
<td>Pawel Kaczmarek<br><a href="mailto:p.kaczmarek3@samsung.com">&#x70;&#x2e;&#x6b;&#x61;&#x63;&#122;&#x6d;&#97;&#x72;&#x65;&#107;&#51;&#64;&#x73;&#x61;&#109;&#115;&#x75;&#x6e;&#x67;&#46;&#99;&#x6f;&#109;</a></td>
</tr>
</tbody>
</table>
<h2 id="overview">Overview</h2>
<p>This document should be used as a guideline for developers who are creating web
plugins for Tizen platform. Conventions and practices described here could be
used to develop new web plugins for Tizen 2.4 platform and higher version.
Each plugin should be written with great attention on JavaScript.</p>
<h2 id="guideline">Guideline</h2>
<h3 id="guideline/languages">Languages</h3>
<p>C++, JavaScript</p>
<h3 id="guideline/codding-style">Codding style</h3>
<p>Use Google style guide,
C++: <a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.html">http://google-styleguide.googlecode.com/svn/trunk/cppguide.html</a></p>
<p>JavaScript: <a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml">http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml</a></p>
<h3 id="guideline/api-guide">API guide</h3>
<p>Tizen Web Device API Guide Lines.pptx
<a href="http://platform.sec.samsung.net/slp/Tizen/Tizen%20Managed%20API/Web%20Device%20API/Tizen%20Web%20Device%20API%20Guide%20Lines.pptx">http://platform.sec.samsung.net/slp/Tizen/Tizen%20Managed%20API/Web%20Device%20API/Tizen%20Web%20Device%20API%20Guide%20Lines.pptx</a></p>
<h3 id="guideline/unit-test-criteria">Unit test criteria</h3>
<p>Tizen-Compliance-Tests-Device-API-UnitTest-Criteria.v0.11_SRPOL.xlsx
<a href="http://platform.sec.samsung.net/slp/Tizen/Tizen%20Managed%20API/Web%20Device%20API/Tizen-Compliance-Tests-Device-API-UnitTest-Criteria.v0.11_SRPOL.xlsx">http://platform.sec.samsung.net/slp/Tizen/Tizen%20Managed%20API/Web%20Device%20API/Tizen-Compliance-Tests-Device-API-UnitTest-Criteria.v0.11_SRPOL.xlsx</a></p>
<h3 id="guideline/source-code">Source code</h3>
<p>For Tizen 2.4:</p>
<pre><code class="lang-sh">$ git clone ssh://&lt;user.id&gt;@168.219.209.56:29418/framework/web/webapi-plugins
$ cd webapi-plugins
$ git checkout origin/tizen_2.4
</code></pre>
<p>For Tizen 3.0</p>
<pre><code class="lang-sh">$ git clone ssh://&lt;user.id&gt;@168.219.209.56:29418/framework/web/webapi-plugins
$ cd webapi-plugins
$ git checkout origin/tizen_3.0
</code></pre>
<h3 id="guideline/license-and-boilerplate">License and Boilerplate</h3>
<p>Use this boilerplate in every new created source files.</p>
<pre><code class="lang-sh">/*
 * Copyright (c) 2015 Samsung Electronics Co., Ltd All Rights Reserved
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
</code></pre>
<h2 id="plugin-structure">Plugin Structure</h2>
<h3 id="plugin-structure/conventions">Conventions</h3>
<p>Each plugin is kept in separate directory inside src/ folder written in lowercase convention.</p>
<h3 id="plugin-structure/structure">Structure</h3>
<p>Each plugin contains following structure:</p>
<ul>
<li><code>&lt;pluginname&gt;.gyp</code></li>
<li><code>&lt;pluginname&gt;_api.js</code></li>
<li><code>&lt;pluginname&gt;_extension.h</code></li>
<li><code>&lt;pluginname&gt;_extension.cc</code></li>
<li><code>&lt;pluginname&gt;_instance.h</code></li>
<li><code>&lt;pluginname&gt;_instance.cc</code></li>
</ul>
<h3 id="plugin-structure/spec-file">Spec file</h3>
<p>Spec file (<code>webapi-plugins.spec</code>) kept inside <code>packaging/</code> directory
is build specification file used by rpm packaging system where variables are defined.
Those variables can be used to include or exclude particular modules from
build for each profile (mobile, TV, wearable).</p>
<h3 id="plugin-structure/gyp-file">GYP file</h3>
<p>Each plugin has its own gyp file that contains information specific for it.
Plugin configuration file (gyp) is the equivalent of CMake.
It contains information what files to build what libraries to use for linking.
There can be also found one main gyp file in <code>src/</code> folder (<code>tizen-wrt.gyp</code>)
that includes others.</p>
<h3 id="plugin-structure/implementation-files">Implementation files</h3>
<p>Description of files required in plugin implementation.</p>
<ul>
<li><strong>C++ files</strong> (<code>&lt;pluginname&gt;_extension.h, &lt;pluginname&gt;_extension.cc</code>)<br>
Extension namespace and other objects exported by JavaScript layer are set inside these files.</li>
<li><strong>C++ files</strong> (<code>&lt;pluginname&gt;_instance.h, &lt;pluginname&gt;_instance.cc</code>)<br>
These files are responsible for communication between JavaScript layer and Native API.</li>
<li><strong>JavaScript file</strong> (<code>&lt;pluginname&gt;_api.js</code>)<br>
This file contains all methods required by each API.
All operation should be done by JavaScript as much as possible.
If JavaScript can do something, it should do it.
This file is responsible for checking privileges, checking arguments, calling C++ methods etc.</li>
</ul>
<h3 id="plugin-structure/plugin-flow">Plugin flow</h3>
<p><img src="images/plugin_flow.png" alt="Plugin flow"></p>
<p>Explanation of steps:</p>
<ol>
<li>From JavaScript Layer information is sent to C++ Layer.
This information consists of type of call (asynchronous, synchronous)
arguments given by user, any additional information that is required to
successfully acquire required data. Data is sent in form of JSON.</li>
<li>C++ parses acquired JSON. After the data is processed. Appropriate platform
functions are called with the specified arguments.</li>
<li>Platform returns specified values to C++ layer.</li>
<li>Another JSON is formed. It consists of data that was acquired from platform.</li>
</ol>
<h2 id="widl">WIDL</h2>
<h3 id="widl/conventions">Conventions</h3>
<p>Currently WIDL version that is used in Samsung is described here: <a href="http://www.w3.org/TR/WebIDL/">http://www.w3.org/TR/WebIDL/</a>.
This is document from 19 April 2012.</p>
<p>WIDL used for plugins creation is closer to previous drafts mainly this from
21 October 2010. It is described here: <a href="http://www.w3.org/TR/2010/WD-WebIDL-20101021/">http://www.w3.org/TR/2010/WD-WebIDL-20101021/</a>.</p>
<h3 id="widl/architecture">Architecture</h3>
<p>Each plugin is separated from each other as a different module.
We do this by using module key name.</p>
<pre class="prettyprint linenums"><code>module identifer {
  definitions
}
</code></pre><p>Each module describes space, binding many connected definitions in one namespace.
Inside each module there are sets of <strong>interface</strong> defined.
Most of the time there is one major interface defined, which is <strong>NoInterfaceObject</strong>.
This is manager object which has only one property which is object that actually
implements manager functionality.</p>
<pre class="prettyprint linenums"><code>interface identifier : indentifier-of-inherited-interface {
  interface-member...
};
</code></pre><p>Interface is a definition of an object, which can be realized in a system
(an inheritance and overloading is possible).
In interface definition you can put following members:</p>
<ul>
<li>Constants.</li>
<li>Attribute : Interface member, which represents variable inside object,
can be changed, if it is not read only.</li>
<li>Operation: Interface member, which represents method inside object.
It is a function of programming language, which can be executed and returns a result.</li>
<li>Special operation: Performs a specific task. i.e. deleter, getter</li>
<li>Static operation: It is not called for a specific instance of the interface,
is called for static object regardless of an instance creation.
It is connected with the interface itself.</li>
</ul>
<pre class="prettyprint linenums"><code>interface identifier {
  attribute type identifier;
  [extended-attribute] const type identifier = value;
  [extended-attribute] attribute type identifier;
  readonly attribute type identifier;
  attribute type identifier inherits getter; ///Declared to change read only attribute //inherited from interface
  attribute type identifier getraises (NoSuchValue); ///Exception declaration
  return-type identifier(arguments…);
  return-type identifier(argument-type argument-identifier); ///regular operation
  return-type identifier(optional argument);
  special-keywords return-type identifier(arguments); ///special operation
  [extended-attribute]return-type identifier(arguments…); ///A variable number of //arguments
  return-type identifier(arguments) raises (identifier) ///raises exception
  caller return-type identifier(argument);
  caller return-type (argument);
  static return-type identifier(arguments);
};
</code></pre><p>Next step is to connect manager implementation with Tizen object.</p>
<pre class="prettyprint linenums"><code>Tizen implements ManagerObject
</code></pre><p>To provide actual implementations of ManagerObject, instance of its Manager
interface definition has to be made. Inside this Manager interface all attributes
and functions that will be available form manager namespace, should be defined.
There can be attributes which are other interfaces, operations and everything
that interfaces allows.</p>
<p>Additional interface can be available as a standalone types not connected to
global namespace. Those are either obtained from operation of other interfaces
or constructed with theirs constructor method. Interface which are constructible
are described as follows:</p>
<pre class="prettyprint linenums"><code>[Constructor(type arg1, optional type? Arg2)]
Interface ConstructibleInterface {
  attributes
  operations
  an so on...
};
</code></pre><p>As one can see list of parameters is specified for such constructor.
Not all parameters are mandatory, some can be preceded by <code>optional</code>
keyword and <code>?</code> mark, after type to mark that this is not obligatory argument.
Additionally some operations can be followed by <code>raises</code> key word to mark that,
described exception type can be thrown during execution of such method.</p>
<p>Because some operations can be asynchronous, it is necessary to provide callbacks
objects that can be executed by such operation. Callback object is special type
of <code>interface</code> object with <code>Callback=FunctionOnly</code> extended attribute.</p>
<pre class="prettyprint linenums"><code>[Callback=FunctionOnly, NoInterfaceObject] interface SomeCallback {
  void someMethod(type agr1, ...)
};
</code></pre><p>On the purpose of listeners which accepts dictionaries, there are callbacks that
support more than one method. There is another definition of callback which
lacks of keyword <code>FunctionOnly</code>.</p>
<pre class="prettyprint linenums"><code>[Callback, NoInterfaceObject] interface SomeDictionaryCallback {
  void firstmethod(type somearg1, ... );
  void secondmethod(type somearg2, ... );
  any additional methods...
};
</code></pre><h3 id="widl/example">Example</h3>
<p>Example of WIDL file:</p>
<pre class="prettyprint linenums"><code>module Sample {

  enum SampleEnums {
    &quot;ENUM1&quot;,
    &quot;ENUM2&quot;,
    &quot;ENUM3&quot;,
  };

  typedef (SampleEnums) SampleType;

  [NoInterfaceObject] interface SampleManagerObject {
    readonly attribute SampleManager sample;
  };

  Tizen implements SampleManagerObject;

  [NoInterfaceObject] interface SampleManager {
    void sampleMethod(SampleType param1, Sample2 param2) raises(WebAPIException);
    double sampleMethod2(SampleType param1) raises(WebAPIException);
    void sampleMethod3(SampleCallback callback) raises(WebAPIException);
  };

  [Callback=FunctionOnly, NoInterfaceObject]
  interface SampleCallback {
    void onsuccess(Sample1 param1, Sample2 param2);
  };
};
</code></pre><h2 id="tools">Tools</h2>
<h3 id="tools/generate-stub-code">Generate stub code</h3>
<p>To generate stub files from the widl you can use stub generator located in
<code>tools/skeleton_generator/</code> directory and run the python command:</p>
<pre><code class="lang-sh">$ python WAPIOven.py -d &lt;stub code destination directory name&gt; &lt;widl directory/pluginname&gt;.widl
</code></pre>
<p>Path to WAPIOven.py:</p>
<pre><code class="lang-sh">$ tools/skeleton_generator/WAPIOven.py
</code></pre>
<p>You need to install jinja2 for WAPIOven.py:</p>
<pre><code class="lang-sh">$ sudo apt-get install python-jinja2
</code></pre>
<p>Example:</p>
<pre><code class="lang-sh">$ sudo apt-get install python-jinja2
$ cd tools/skeleton_generator/
$ python WAPIOven.py -d ../../src/notification/ /web-device-api/web/widl/tizen/notification.widl
</code></pre>
<p>WIDL files can be found in the project repository:</p>
<pre><code class="lang-sh">$ git clone ssh://&lt;username&gt;@168.219.209.56:29418/doc/web-device-api
</code></pre>
<p>The widl files are placed in: <code>web-device-api/web/widl/tizen/</code></p>
<p>Stub files generated by above command:</p>
<pre><code class="lang-sh">&lt;pluginname&gt;_api.js
&lt;pluginname&gt;_extension.h
&lt;pluginname&gt;_extension.cc
&lt;pluginname&gt;_instance.h
&lt;pluginname&gt;_instance.cc
</code></pre>
<p>What should be done when skeleton code was generated?</p>
<ul>
<li><code>&lt;pluginname&gt;.gyp</code> file should be added</li>
<li>required privileges should be added in JavaScript file</li>
<li>entry points should be checked in <code>&lt;pluginname&gt;_extension.cc</code> file</li>
<li>each method should be implemented in <code>&lt;pluginname&gt;_instance.cc</code> file</li>
</ul>
<h3 id="tools/using-multiple-javascript-files">Using multiple JavaScript files</h3>
<p>To use multiple JavaScript files in one plugin create <code>js/</code> directory inside
plugin directory and place JavaScript files.</p>
<p>Inside <code>&lt;pluginname&gt;_api.js</code> required JavaScript files should be added:</p>
<pre><code class="lang-sh">//= require(&#39;common.js&#39;);
//= require(&#39;calendar_item.js&#39;);
//= require(&#39;calendar.js&#39;);
//= require(&#39;calendar_manager.js&#39;);
//= require(&#39;calendar_attendee.js&#39;);
//= require(&#39;calendar_alarm.js&#39;);
//= require(&#39;calendar_recurrence_rule.js&#39;);
</code></pre>
<p>To merge all JavaScript files <code>tools/mergejs.py</code> file is used.
This script merge all files mentioned in <code>&lt;pluginname&gt;_api.js</code> file into one
file before build process.</p>
<h2 id="implementation-javascript">Implementation - JavaScript</h2>
<p>Each plugin contains JavaScript files. This is the place where user input is
being processed validated before send to C++ layer.</p>
<p>Badge API will be used to show the creation of JavaScript file (lot of content
of this file will be already generated via Stub Generator).</p>
<h3 id="implementation-javascript/interface-creation">Interface creation</h3>
<p>The WIDL of BadgeManager – main entity that holds all the API methods
looks like following:</p>
<pre class="prettyprint linenums"><code>[NoInterfaceObject] interface BadgeManager {
  readonly attribute long maxBadgeCount
  void setBadgeCount(ApplicationId appId, long count) raises(WebAPIException);
  long getBadgeCount(ApplicationId appId) raises(WebAPIException);
  void addChangeListener(ApplicationId[]appIdList, BadgeChangeCallback successCallback) raises(WebAPIException);
  void removeChangeListener(ApplicationId[] appIdList) raises(WebAPIException);
};
</code></pre><h3 id="implementation-javascript/creating-manager-entity">Creating Manager entity</h3>
<p>Object that will hold attributes and methods is defined as JavaScript function:</p>
<pre class="prettyprint linenums"><code class="lang-js">function BadgeManager() {}
</code></pre>
<h3 id="implementation-javascript/properties-definition">Properties definition</h3>
<p>Properties are defined within the created JavaScript function like this:</p>
<pre class="prettyprint linenums"><code class="lang-js">var MAX_BADGE_COUNT = 999;
Object.defineProperties(this, {
  maxBadgeCount: {value: MAX_BADGE_COUNT, emumerable: true, writable: false}
});
</code></pre>
<p>Because the property was defined as <code>const</code>, writable is set to false.</p>
<h3 id="implementation-javascript/methods-definition">Methods definition</h3>
<p>In accordance to WIDL BadgeManager contains setBadgeCount method.
To define this method within JavaScript use prototype extension functionality:</p>
<pre class="prettyprint linenums"><code class="lang-js">BadgeManager.prototype.setBadgeCount = function() {};
</code></pre>
<h3 id="implementation-javascript/exporting-interface">Exporting interface</h3>
<p>Once the object is created and all the methods and attributes are set it has to
be exported so it will be visible when making call to tizen.badge namespace.
This is done using assigning new object instance to exports variable:</p>
<pre class="prettyprint linenums"><code class="lang-js">exports = new BadgeManager(); //exported as tizen.badge
exports = new CalendarManager(); //exported as tizen.calendar
</code></pre>
<p>Other namespaces within the module are exported as below:</p>
<pre class="prettyprint linenums"><code class="lang-js">tizen.CalendarAttendee = CalendarAttendee;
tizen.CalendarEvent = CalendarEvent;
tizen.CalendarTask = CalendarTask;
</code></pre>
<h3 id="implementation-javascript/utils">Utils</h3>
<p>In <code>src/utils/utils_api.js</code> file there is a lot of useful tools that allow
automatization of certain operations. Most often used tools from utils_api.js
are converter and validator. All tools are available under <code>xwalk.utils</code> namespace.</p>
<h4 id="converter">Converter</h4>
<p>A lot of times conversion between JavaScript types will be required.
The converter tool was created in order to make this operation easier.</p>
<pre class="prettyprint linenums"><code class="lang-js">var converter_ = xwalk.utils.converter;
var number = converter_.toLong(result);
</code></pre>
<h4 id="validator">Validator</h4>
<p>When API JavaScript method is called first thing that has to be done in
JavaScript layer of api implementation is to process and validate arguments
given by the user. The process of validation consists of ensuring that the
proper amount of arguments was given and that they were of the expected
type and throwing exception if necessary.</p>
<p>Validator helps to ensure that user sent proper values. Validator is available
at <code>xwalk.utils.validator</code> and predefined js types at <code>xwalk.utils.validator.types</code></p>
<p>Below can be found example of using validator inside <code>setBadgeCount</code> method
that requires appId in form of string and long count value:</p>
<pre class="prettyprint linenums"><code class="lang-js">var validator_ = xwalk.utils.validator;
var types_ = validator_.Types;

var args = validator_.validateArgs(arguments, [
  {name: &#39;appId&#39;, type: types_.STRING},
  {name: &#39;count&#39;, type: types_.LONG}
]);
</code></pre>
<h4 id="privileges">Privileges</h4>
<p>Some of the API methods require privilege access, then it&#39;s the first step
in JavaScript file which should be checked.</p>
<p>Below can be found example of using Privilege in Alarm API:</p>
<pre class="prettyprint linenums"><code class="lang-js">var Privilege = xwalk.utils.privilege;

// inside add, remove, removeAll methods:
xwalk.utils.checkPrivilegeAccess(Privilege.ALARM);
</code></pre>
<h3 id="implementation-javascript/exceptions">Exceptions</h3>
<p>At some point whether improper data is received or given to JavaScript might
require to throw exceptions. The example below shows how to throw properly
predefined exceptions:</p>
<pre class="prettyprint linenums"><code class="lang-js">throw new WebAPIException(WebAPIException.TYPE_MISMATCH_ERR,
                          &#39;Incorrect number of arguments&#39;);
</code></pre>
<p>WebAPIException constructor takes as argument the type of error to be thrown.
The second additional argument is error message.</p>
<h3 id="implementation-javascript/synchronous-methods">Synchronous methods</h3>
<p>In order to perform synchronous operation (one that does not require callback
and the result is given instantly) callSync() method of Native manager needs
to be called:</p>
<pre class="prettyprint linenums"><code class="lang-js">var native_ = new xwalk.utils.NativeManager(extension);
var ret = native_.callSync(&#39;BadgeManager_setBadgeCount&#39;, {
  appId: args.appId,
  count: args.count
});
if (native_.isFailure(ret)) {
  throw native_.getErrorObject(ret);
}
</code></pre>
<p>The first argument is the command name registered in C++ layer that has to be called,
the second is arguments object that will be passed to this method.
Result is assigned to ret variable.</p>
<h3 id="implementation-javascript/asynchronous-methods">Asynchronous methods</h3>
<p>In order to work with method that requires callback instead of callSync(),
call() method needs to be called. Apart from the first two arguments that are
exactly the same as in call() method (c++ method binding, object) it takes
additional argument that is a function that will be called when the native
call is processed:</p>
<pre class="prettyprint linenums"><code class="lang-js">var native_ = new xwalk.utils.NativeManager(extension);
var callback = function(result) {
  if (native_.isFailure(result)) {
    native_.callIfPossible(args.errorCallback, native_.getErrorObject(result));
  } else {
    var calendars = native_.getResultObject(result);
    var c = [];
    calendars.forEach(function(i) {
      c.push(new Calendar(new InternalCalendar(i)));
    });
    args.successCallback(c);
  }
};

native_.call(&#39;CalendarManager_getCalendars&#39;, callArgs, callback);
</code></pre>
<h3 id="implementation-javascript/listeners">Listeners</h3>
<p>In order to work with listeners NativeManager provides <code>addListener</code> and
<code>removeListener</code> methods. This method takes two arguments: one is unique
<code>listenerId</code> that will be processed when making a call from C++ to JavaScript.
The second one is the function that is called whenever expected event occurs.</p>
<pre class="prettyprint linenums"><code class="lang-js">var native_ = new xwalk.utils.NativeManager(extension);
var listenerId = &#39;PLUGIN_LISTENER_NAME&#39;;
native_.addListener(listenerId, function(data) {
  // handle event data
});
native.callSync(&#39;Calendar_addChangeListener&#39;, {
  type: this.type,
  listenerId: listenerId
});
</code></pre>
<h2 id="implementation-c">Implementation - C++</h2>
<h3 id="implementation-c/lifecycle-and-plugin-state">Lifecycle and plugin state</h3>
<p>All plugins instances are created by runtime on application launch.
It&#39;s important to not initialize any database/service connections and platform
handlers in instance constructor. All resources should be &quot;lazy&quot; initialized
just before first use, to keep starting time as short as possible.
Initialized resources can be referenced to instance and kept for further usage.
Instance destructor is called on application termination and should release all
used resources to prevent memory leaks.</p>
<p>Native layer should be considered as stateless. It means that there is
no strict reference between JavaScript and native data.<br>
Example: If operation should change some object retrieved from platform,
identifier should be passed again and additional check if object still exists
should be made.</p>
<h3 id="implementation-c/namespace-and-entry-points">Namespace and entry points</h3>
<p>Extension namespace and other objects exported by JavaScript layer are defined
inside <code>&lt;pluginname&gt;_extension.cc</code> file.</p>
<pre class="prettyprint linenums"><code class="lang-cpp">SetExtensionName(&quot;tizen.notification&quot;); //exported in JS as new NotificationManager();
const char* entry_points[] = {&quot;tizen.StatusNotification&quot;,
                              &quot;tizen.NotificationDetailInfo&quot;,
                              NULL};
</code></pre>
<h3 id="implementation-c/plugin-structure">Plugin structure</h3>
<p>In general <code>Instance</code> class (<code>&lt;pluginname&gt;_instance.cc</code>) should be
treated as command dispatcher and should be as small as possible (similar to Controller in MVC).
It&#39;s responsibility should be limited to reading/validating arguments,
forwarding call to business logic component and passing result to JavaScript layer.
Business logic should be implemented in additional classes with
<a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a> principles in mind.</p>
<p>Commands callable from JavaScript layer should be registered in constructor of
<code>&lt;PluginName&gt;Instance</code> class which extends <code>common::ParsedInstance</code>.</p>
<pre class="prettyprint linenums"><code class="lang-cpp">// &lt;pluginname&gt;_instance.h
class MediaControllerInstance : public common::ParsedInstance {}
</code></pre>
<p>Currently there is no difference in registering sync and async commands.
But good practice is to separate them for readability and maintainability.
Common practice is to define two macros and call <code>RegisterSyncHandler</code>
method from <code>common::ParsedInstance</code>.</p>
<pre class="prettyprint linenums"><code class="lang-cpp">// &lt;pluginname&gt;_instance.cc
MediaControllerInstance::MediaControllerInstance() {
  #define REGISTER_SYNC(c, x) \
      RegisterSyncHandler(c, std::bind(&amp;MediaControllerInstance::x, this, _1, _2));
  #define REGISTER_ASYNC(c, x) \
      RegisterSyncHandler(c, std::bind(&amp;MediaControllerInstance::x, this, _1, _2));

  REGISTER_SYNC(&quot;MediaControllerManager_getClient&quot;,
      MediaControllerManagerGetClient);
  REGISTER_ASYNC(&quot;MediaControllerClient_findServers&quot;,
      MediaControllerClientFindServers);

  // ... other commands

  #undef REGISTER_SYNC
  #undef REGISTER_ASYNC
}
</code></pre>
<p>Static method registered as a handler must have proper signature:</p>
<pre class="prettyprint linenums"><code class="lang-cpp">void InstanceClass::HandlerName(const picojson::value&amp; args, picojson::object&amp; out);
</code></pre>
<ul>
<li><code>args</code> - object containing arguments passed from JavaScript layer</li>
<li><code>out</code> - object containing response data returned synchronously to JavaScript
layer.</li>
</ul>
<p><code>ReportSuccess()</code> or <code>ReportError()</code> helpers should be used to ensure
proper structure of <code>out</code> object.</p>
<pre class="prettyprint linenums"><code class="lang-cpp">picojson::value data = picojson::value&lt;picojson::object());
const PlatformResult&amp; result = model_-&gt;DoSomethingWithData(&amp;data);
if (!result) {
  LOGGER(ERROR) &lt;&lt; result.message();
  ReportError(result, &amp;out);
  return;
}

ReportSuccess(data, out);
</code></pre>
<h3 id="implementation-c/asynchronous-calls">Asynchronous calls</h3>
<p>To perform asynchronous request <code>common::TaskQueue</code> component should be used.
You should use lambda expression which calls business logic and passes result to
JavaScript layer by calling <code>PostMessage(const char* msg)</code>.</p>
<p>Asynchronous response is not matched to request automatically. You should pass
<code>callbackId</code> received from JavaScript layer as an argument. It allows to
call the appropriate user callback in JS async message handler.</p>
<pre class="prettyprint linenums"><code class="lang-cpp">auto search = [this, args]() -&gt; void {

  // business logic
  picojson::value servers = picojson::value(picojson::array());
  PlatformResult result = client_-&gt;FindServers(&amp;servers.get&lt;picojson::array&gt;());

  // response object
  picojson::value response = picojson::value(picojson::object());
  picojson::object&amp; response_obj = response.get&lt;picojson::object&gt;();
  response_obj[&quot;callbackId&quot;] = args.get(&quot;callbackId&quot;);
  if (result) {
    ReportSuccess(servers, response_obj);
  } else {
    ReportError(result, &amp;response_obj);
  }

  // post JSON string to JS layer
  PostMessage(response.serialize().c_str());
};

TaskQueue::GetInstance().Async(search);
</code></pre>
<h3 id="implementation-c/listeners">Listeners</h3>
<p>Sending events from platform listeners is very similar to sending asynchronous
responses. <code>PostMessage(const char* msg)</code> should be called with <code>listenerId</code>
passed from JavaScript layer.</p>
<pre class="prettyprint linenums"><code class="lang-cpp">auto listener = [this, args](picojson::value* data) -&gt; void {

  if (!data) {
    LOGGER(ERROR) &lt;&lt; &quot;No data passed to json callback&quot;;
    return;
  }

  picojson::object&amp; request_o = data-&gt;get&lt;picojson::object&gt;();
  request_o[&quot;listenerId&quot;] = args.get(&quot;listenerId&quot;);

  PostMessage(data-&gt;serialize().c_str());
};
</code></pre>
<h3 id="implementation-c/logger">Logger</h3>
<p>Logger is available from <code>common/logger.h</code> header. There are macros:</p>
<ul>
<li><code>LOGGER(priority)</code> prints message with given priority</li>
<li><code>LOGGER_IF(priority, condition)</code> prints message with given priority when condition is met</li>
</ul>
<p>Available log priorities are: <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>
and should be used to filter messages based on level of importance. Example:</p>
<pre class="prettyprint linenums"><code class="lang-cpp">LOGGER(ERROR) &lt;&lt; &quot;Scan file failed, error: &quot; &lt;&lt; res;
LOGGER_IF(DEBUG, variable &lt; 0) &lt;&lt; &quot;Value is lower than zero&quot;;
</code></pre>
<h3 id="implementation-c/error-handling">Error handling</h3>
<p>Regarding to <a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.html#Exceptions">Google C++ Style Guide</a> we do not use Exceptions.</p>
<p>To deliver error conditions to JavaScript layer, that can occur in the platform,
<code>PlatformResult</code> class should be used. All available error codes are defined
in <code>common/platform_result.h</code></p>
<p>PlatformResult can be returned anywhere in native layer and it should be
converted to exception and thrown in JavaScript layer:</p>
<pre class="prettyprint linenums"><code class="lang-cpp">// C++ layer
return PlatformResult(ErrorCode::NOT_FOUND_ERR, &quot;Cannot remove notification error&quot;);
return PlatformResult(ErrorCode::UNKNOWN_ERR, &quot;Cannot get notification id error&quot;);
</code></pre>
<pre class="prettyprint linenums"><code class="lang-js">// JavaScript layer
var native_ = new xwalk.utils.NativeManager(extension);
if (native_.isFailure(ret)) {
  throw native_.getErrorObject(ret);
}
</code></pre>
<h2 id="devel-package">Devel package</h2>
<p>After build process webapi-plugins-devel-xxx.rpm should be generated in gbs directory.
Package contains required common headers files, gypi files and webapi-plugins.pc file.</p>
<h3 id="devel-package/package-structure">Package structure</h3>
<pre><code class="lang-sh">|-usr
|---include
|-----webapi-plugins
|-------src
|---------common
|-------tools
|---------gyp
|-----------pylib
|-------------gyp
|---------------generator
|---lib
|-----pkgconfig
</code></pre>
<p>File webapi-plugins.pc source:</p>
<pre class="prettyprint linenums"><code>project_name=webapi-plugins
dirname=tizen-extensions-crosswalk
prefix=/usr
exec_prefix=${prefix}
libdir=${prefix}/lib/${dirname}
includedir=${prefix}/include/${project_name}/src

Name: ${project_name}
Description: ${project_name}
Version:
Requires: dbus-1 dlog glib-2.0
Libs: -L${libdir} -ltizen_common
Cflags: -I${includedir}
</code></pre><h3 id="devel-package/creating-custom-web-device-plugins-module">Creating custom web device plugins module</h3>
<p>To create custom web device plugins module <code>webapi-plugins.spec</code>, <code>tizen-wrt.gyp</code> and <code>src</code> files are needed.
Skeleton below shows the required structure of test module.</p>
<pre><code class="lang-sh">├── packaging
│   └── webapi-plugins.spec
└── src
│   ├── test
│   ├── test_api.js
│   ├── test_extension.cc
│   ├── test_extension.h
│   ├── test.gyp
│   ├── test_instance.cc
│   └── test_instance.h
└── tizen-wrt.gyp
</code></pre>
<p>webapi-plugins.spec source:</p>
<pre class="prettyprint linenums"><code>%define _manifestdir %{TZ_SYS_RW_PACKAGES}
%define _desktop_icondir %{TZ_SYS_SHARE}/icons/default/small

%define crosswalk_extensions tizen-extensions-crosswalk

Name:       webapi-plugins-test
Version:    0.1
Release:    0
License:    Apache-2.0 and BSD-2.0 and MIT
Group:      Development/Libraries
Summary:    Tizen Web APIs implemented
Source0:    %{name}-%{version}.tar.gz

BuildRequires: ninja
BuildRequires: pkgconfig(webapi-plugins)

%description
Tizen Test Web APIs.

%prep
%setup -q

%build

export GYP_GENERATORS=&#39;ninja&#39;
GYP_OPTIONS=&quot;--depth=. -Dtizen=1 -Dextension_build_type=Debug -Dextension_host_os=%{tizen_profile_name} -Dprivilege_engine=%{tizen_privilege_engine}&quot;
GYP_OPTIONS=&quot;$GYP_OPTIONS -Ddisplay_type=x11&quot;

/usr/include/webapi-plugins/tools/gyp/gyp $GYP_OPTIONS src/tizen-wrt.gyp

ninja -C out/Default %{?_smp_mflags}

%install
mkdir -p %{buildroot}%{_libdir}/%{crosswalk_extensions}
install -p -m 644 out/Default/libtizen*.so %{buildroot}%{_libdir}/%{crosswalk_extensions}

%files
%{_libdir}/%{crosswalk_extensions}/libtizen*.so
</code></pre><p>tizen-wrt.gyp source:</p>
<pre class="prettyprint linenums"><code>{
  &#39;includes&#39;:[
    &#39;/usr/include/webapi-plugins/src/common/common.gypi&#39;,
  ],

  &#39;targets&#39;: [
    {
      &#39;target_name&#39;: &#39;extensions&#39;,
      &#39;type&#39;: &#39;none&#39;,
      &#39;dependencies&#39;: [
        &#39;test/test.gyp:*&#39;,
      ],
      &#39;conditions&#39;: [],
    },
  ],
}
</code></pre><p>test.gyp source:</p>
<pre class="prettyprint linenums"><code>{
  &#39;includes&#39;:[
    &#39;/usr/include/webapi-plugins/src/common/common.gypi&#39;,
  ],
  &#39;targets&#39;: [
    {
      &#39;target_name&#39;: &#39;tizen_test&#39;,
      &#39;type&#39;: &#39;loadable_module&#39;,
      &#39;sources&#39;: [
        &#39;test_api.js&#39;,
        &#39;test_extension.cc&#39;,
        &#39;test_extension.h&#39;,
        &#39;test_instance.cc&#39;,
        &#39;test_instance.h&#39;,
      ],
      &#39;include_dirs&#39;: [
        &#39;../&#39;,
        &#39;&lt;(SHARED_INTERMEDIATE_DIR)&#39;,
      ],
      &#39;variables&#39;: {
        &#39;packages&#39;: [
          &#39;webapi-plugins&#39;,
        ],
      },
    },
  ],
}
</code></pre><p><a href="../src/assets/webapi-plugins-devel-test.zip">webapi-plugins-devel-test.zip</a> contains test module which depends on webapi-plugins devel package.
Custom web device plugins module test is placed in <code>src/</code> directory and contains all required files.
Please see <a href="#plugin-structure">Plugin structure</a> chapter for more details.</p>
<p>To install custom web device plugins module <code>webapi-plugins-xxx.rpm</code> and <code>webapi-plugins-devel-xxx.rpm</code> must be installed first.
After build and installation webapi-plugins-devel-test <code>tizen.test</code> namespace should be available.</p>
<pre class="prettyprint linenums"><code class="lang-javascript">var test = tizen.test.ping();
console.log(test); // Hello!
</code></pre>

</div>
<script src="js/mootools-yui-compressed.js"></script>
<script src="js/moostrap-scrollspy.js"></script>
<script src="js/prettify.js"></script>
<script src="js/lang-css.js"></script>
<script src="js/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script src="js/doctor.js"></script>
</body>
</html>
